"""
Text Summarization MCP Server

Provides tools for text summarization using Azure OpenAI.
Implements access control and secure communication.
"""

import asyncio
import json
import os
from typing import Any

import mcp.types as types
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.stdio import stdio_server

# Add parent directory to path for imports
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

from shared.crypto_utils import KeyManager, create_encrypted_response, decrypt_mcp_request
from shared.config import Config, LogConfig

# Setup logging
logger = LogConfig.setup_logging("summarization_server")

# Initialize key manager
key_manager = KeyManager(
    key_dir=os.path.join(Config.KEYS_BASE_DIR, "summarization_server"),
    entity_name="summarization_server"
)

# Create MCP server
server = Server("text-summarization-server")

# Validate Azure OpenAI configuration
azure_config_valid, missing_configs = Config.validate_azure_openai_config()


def perform_summarization(text: str) -> str:
    """Perform text summarization using Azure OpenAI."""
    if not azure_config_valid:
        error_msg = f"Azure OpenAI not configured. Missing: {', '.join(missing_configs)}"
        logger.error(error_msg)
        return f"Error: {error_msg}"
    
    try:
        from openai import AzureOpenAI
        
        client = AzureOpenAI(
            api_key=Config.AZURE_OPENAI_API_KEY,
            api_version=Config.AZURE_OPENAI_API_VERSION,
            azure_endpoint=Config.AZURE_OPENAI_ENDPOINT
        )
        
        response = client.chat.completions.create(
            model=Config.AZURE_OPENAI_DEPLOYMENT_NAME,
            messages=[
                {
                    "role": "system", 
                    "content": "You are an AI assistant that expertly summarizes provided text into a few key sentences."
                },
                {
                    "role": "user", 
                    "content": f"Please provide a concise summary of the following text:\n\n{text}"
                }
            ],
            max_tokens=200,
            temperature=0.5
        )
        
        summary = response.choices[0].message.content
        logger.info("Summary successfully generated by Azure OpenAI")
        return summary
        
    except Exception as e:
        error_msg = f"Error during summarization: {str(e)[:100]}"
        logger.error(error_msg)
        return f"Error: {error_msg}"


@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    """List available tools for text summarization."""
    return [
        types.Tool(
            name="summarize_text",
            description="Generate a concise summary of the provided text using AI",
            inputSchema={
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "The text to summarize"
                    },
                    "access_key": {
                        "type": "string",
                        "description": "Access key for authorization"
                    },
                    "requester_public_key": {
                        "type": "string",
                        "description": "PEM-encoded public key of the requesting entity"
                    },
                    "encrypted": {
                        "type": "boolean",
                        "description": "Whether to return encrypted response",
                        "default": False
                    }
                },
                "required": ["text", "access_key", "requester_public_key"]
            }
        ),
        types.Tool(
            name="check_service_status",
            description="Check the status of the summarization service",
            inputSchema={
                "type": "object",
                "properties": {
                    "requester_public_key": {
                        "type": "string",
                        "description": "PEM-encoded public key of the requesting entity"
                    }
                },
                "required": ["requester_public_key"]
            }
        ),
        types.Tool(
            name="get_server_public_key",
            description="Get the server's public key for establishing secure communication",
            inputSchema={
                "type": "object",
                "properties": {},
                "required": []
            }
        )
    ]


@server.call_tool()
async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
    """Handle tool calls for text summarization."""
    
    try:
        if name == "get_server_public_key":
            # Return server's public key (unencrypted)
            result = {
                "server_public_key": key_manager.get_public_key_pem(),
                "server_id": "summarization_server",
                "service_available": azure_config_valid
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        elif name == "check_service_status":
            requester_public_key = arguments.get("requester_public_key")
            
            if not requester_public_key:
                raise ValueError("Missing required argument: requester_public_key")
            
            result = {
                "service_status": "operational" if azure_config_valid else "configuration_error",
                "azure_openai_configured": azure_config_valid,
                "missing_configurations": missing_configs if not azure_config_valid else [],
                "available_access_keys_count": len(Config.VALID_ACCESS_KEYS)
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        elif name == "summarize_text":
            text = arguments.get("text")
            access_key = arguments.get("access_key") 
            requester_public_key = arguments.get("requester_public_key")
            encrypt_response = arguments.get("encrypted", False)
            
            if not text or not access_key or not requester_public_key:
                raise ValueError("Missing required arguments: text, access_key, or requester_public_key")
            
            logger.info(f"Summarization request received with access key: {access_key}")
            
            # Validate access key
            if access_key not in Config.VALID_ACCESS_KEYS:
                logger.warning(f"Invalid access key: {access_key}")
                result = {
                    "error": "Invalid or unauthorized access key",
                    "status": "forbidden",
                    "access_granted": False
                }
            else:
                logger.info(f"Access key validated: {access_key}")
                
                # Perform summarization
                summary = perform_summarization(text)
                
                if summary.startswith("Error:"):
                    result = {
                        "error": summary,
                        "status": "service_error",
                        "access_granted": True
                    }
                else:
                    result = {
                        "summary": summary,
                        "status": "success",
                        "access_granted": True,
                        "text_length": len(text),
                        "summary_length": len(summary)
                    }
            
            # Encrypt response if requested
            if encrypt_response:
                encrypted_result = create_encrypted_response(
                    result,
                    requester_public_key,
                    key_manager
                )
                response_text = json.dumps(encrypted_result, indent=2)
            else:
                response_text = json.dumps(result, indent=2)
            
            return [types.TextContent(
                type="text",
                text=response_text
            )]
            
        else:
            raise ValueError(f"Unknown tool: {name}")
            
    except Exception as e:
        logger.error(f"Error handling tool {name}: {e}")
        error_result = {
            "error": str(e),
            "tool": name,
            "success": False
        }
        
        return [types.TextContent(
            type="text",
            text=json.dumps(error_result, indent=2)
        )]


async def main():
    """Run the text summarization MCP server."""
    logger.info("Starting Text Summarization MCP Server")
    logger.info(f"Server public key: {key_manager.get_public_key_pem()[:100]}...")
    logger.info(f"Azure OpenAI configured: {azure_config_valid}")
    
    if not azure_config_valid:
        logger.warning(f"Missing Azure OpenAI configurations: {missing_configs}")
        logger.warning("Summarization service will not function correctly")
    else:
        logger.info("All Azure OpenAI configurations present")
    
    logger.info(f"Valid access keys: {len(Config.VALID_ACCESS_KEYS)}")
    
    # Initialize server options
    init_options = InitializationOptions(
        server_name="text-summarization-server", 
        server_version="1.0.0"
    )
    
    # Run the server
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            init_options
        )


if __name__ == "__main__":
    asyncio.run(main())
